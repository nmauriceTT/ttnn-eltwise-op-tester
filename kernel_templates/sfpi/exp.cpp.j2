sfpi_inline sfpi::vFloat poly_eval(sfpi::vFloat x) {

    return {{ SFPI_POLY_APPROX }};
}

sfpi_inline sfpi::vInt _float_to_int32_exp21f_(sfpi::vFloat val) {
    sfpi::vInt exp = exexp(val);
    sfpi::vInt man = exman8(val);  // get mantissa with implicit bit (man in [1; 2])
    sfpi::vInt shift = exp - 23;
    man = sfpi::reinterpret<sfpi::vInt>(shft(sfpi::reinterpret<sfpi::vUInt>(man), shift));
    return man;
}

template <bool is_fp32_dest_acc_en = false>
sfpi_inline sfpi::vFloat calculate_sfpi_kernel(sfpi::vFloat val) {
    sfpi::vFloat y = sfpi::vConst0;
    sfpi::vFloat threshold_high = sfpi::vFloat(89);
    sfpi::vFloat threshold_low = sfpi::vFloat(-88.5);
    vec_min_max(threshold_low, val);
    vec_min_max(val, threshold_high);

    sfpi::vInt z = _float_to_int32_exp21f_(val * sfpi::vFloat(0x00b8aa3b) + sfpi::vFloat(0x3f800000));
    sfpi::vInt exponential_part =
        exexp_nodebias(sfpi::reinterpret<sfpi::vFloat>(z));
    sfpi::vInt fractional_part =
        sfpi::exman9(sfpi::reinterpret<sfpi::vFloat>(z));

    sfpi::vFloat frac = sfpi::int32_to_float(fractional_part, 0) * sfpi::vFloat(1.1920929e-7f);
    
    frac = poly_eval(frac);
    
    exponential_part = sfpi::reinterpret<sfpi::vInt>(
        sfpi::setexp(sfpi::reinterpret<sfpi::vFloat>(frac), exponential_part));  // restore exponent

    y = sfpi::reinterpret<sfpi::vFloat>(exponential_part);

    if constexpr (!is_fp32_dest_acc_en) {
        y = sfpi::reinterpret<sfpi::vFloat>(sfpi::float_to_fp16b(y, 0));
    }

    return y;
}

void calculate_sfpi_kernel_init() {
}