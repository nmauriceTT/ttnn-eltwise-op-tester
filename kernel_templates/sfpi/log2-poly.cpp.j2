sfpi_inline sfpi::vFloat poly_eval(sfpi::vFloat x) {

    return {{ SFPI_POLY_APPROX }};
}


template <bool is_fp32_acc_to_dest_mode = true>
sfpi_inline sfpi::vFloat calculate_sfpi_kernel(sfpi::vFloat val) {

    // log(1/x) = -log(x)
    // log2(x) = exexp(x) + log2(setexp(x, 127))

    // Normalize base to calculation range       // set base as positive
    sfpi::vFloat x = sfpi::setexp(val, 127);

    // 3rd order polynomial approx - determined using rminimax over [1,2]
    sfpi::vFloat series_result = poly_eval(x - sfpi::vConst1);

    // Convert exponent to float
    sfpi::vInt exp = sfpi::exexp(val);
    v_if(exp < 0) { exp = sfpi::setsgn(~exp + 1, 1); }
    v_endif;
    sfpi::vFloat exp_f32 = sfpi::int32_to_float(exp, 0);

    sfpi::vFloat result = exp_f32 + series_result;  // exp correction: ln(1+x) + exp*ln(2)

    if constexpr(!is_fp32_acc_to_dest_mode) {
        result = sfpi::reinterpret<sfpi::vFloat>(sfpi::float_to_fp16b(result, 0));
    }

    return result;
}

inline void calculate_sfpi_kernel_init()
{
}