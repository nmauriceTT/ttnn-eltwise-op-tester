template <bool is_fp32_acc_to_dest_mode>
sfpi_inline sfpi::vFloat calculate_sfpi_kernel(sfpi::vFloat val) {

    sfpi::vFloat t0 = sfpi::abs(val);
    v_if(t0 > 1) { t0 = _sfpu_reciprocal_<is_fp32_acc_to_dest_mode ? 2 : 1>(t0); }
    v_endif;

    sfpi::vFloat t1 = t0 * t0;

    // Found using Sollya:
    // > fpminimax(atan(x), [|1,3,5,7|], [|single...|], [2^(-40); 1], relative);
    // bf16: x * (0.998424112796783447265625 + x^2 * (-0.301038801670074462890625 + x^2 * 8.925057947635650634765625e-2))

    // t1 = POLYVAL6(-0.013480470f, 0.057477314f, -0.121239071f, 0.195635925f, -0.332994597f, 0.999995630f, t1);
    
    
    // Found using Sollya:
    // > fpminimax(atan(x), [|1,3,5,7,9,11,13,15,17|], [|single...|], [2^(-40); 1], relative);
    t1 = PolynomialEvaluator::eval(
        t1,
        {{ POLY_COEFFS }}
    );


    t1 = t1 * t0;

    v_if(sfpi::abs(val) > 1) { t1 = 1.570796327f - t1; }
    v_endif;

    return sfpi::setsgn(t1, val);   
}

template <bool is_fp32_acc_to_dest_mode>
inline void calculate_sfpi_kernel_init()
{
    // Initialisation for use of sfpu_reciprocal<false>.
    _init_reciprocal_<false, is_fp32_acc_to_dest_mode, false>();
}